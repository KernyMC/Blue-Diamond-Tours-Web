---
interface Props {
  // Clase para el alto (ej: 'h-[500px]')
  heightClass?: string;
  // CUANTOS items quieres ver a la vez (2, 3, 4, 5...)
  visibleItems?: number;
  // Si el carrusel debe ser infinito
  infinite?: boolean;
  // Tipo de indicador: 'numbers' (1/5), 'dots' (puntos), 'none' (ninguno)
  indicator?: 'numbers' | 'dots' | 'none';
  // Tiempo en milisegundos para autoplay (0 = desactivado)
  autoplay?: number;
}

const { 
  heightClass = "h-[500px]", 
  visibleItems = 4,
  infinite = false,
  indicator = "numbers",
  autoplay = 0
} = Astro.props;

// Generar ID único para este carousel
const carouselId = `carousel-${Math.random().toString(36).substr(2, 9)}`;
---

<div class={`relative w-full ${heightClass} group carousel-container`} data-carousel-id={carouselId}>
  
  <button 
    class="btn-prev absolute left-4 top-1/2 -translate-y-1/2 z-20 bg-black/20 hover:bg-black/60 text-white p-3 rounded-full transition-colors backdrop-blur-[2px]"
  >
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
      <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
    </svg>
  </button>

  <div 
    class="carousel-track flex w-full h-full overflow-x-auto snap-x snap-mandatory scrollbar-hide cursor-grab active:cursor-grabbing"
    style={`--items-count: ${visibleItems};`}
    data-infinite={infinite}
    data-autoplay={autoplay}
  >
    <slot />
  </div>

  <button 
    class="btn-next absolute right-4 top-1/2 -translate-y-1/2 z-20 bg-black/20 hover:bg-black/60 text-white p-3 rounded-full transition-colors backdrop-blur-[2px]"
  >
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
      <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
    </svg>
  </button>

  {indicator !== 'none' && (
    <div class="absolute bottom-2 left-1/2 -translate-x-1/2 z-[100]">
      {indicator === 'numbers' ? (
        <span class="counter bg-black/50 text-white px-4 py-1 rounded-full text-sm font-bold border border-white/30 backdrop-blur-md">
          1 / --
        </span>
      ) : (
        <div class="dots-container flex gap-2 bg-black/50 px-3 py-2 rounded-full border border-white/30 backdrop-blur-md">
          <!-- Los dots se generarán dinámicamente con JavaScript -->
        </div>
      )}
    </div>
  )}


</div>

<style>
  /* Ocultar scrollbar */
  .scrollbar-hide::-webkit-scrollbar { display: none; }
  .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }

  /* Evitar selección de texto durante el drag */
  .carousel-track {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  /* LÓGICA DE LOS ITEMS:
    Seleccionamos todos los hijos directos del track (tus cards).
    
    1. Móvil (pantallas pequeñas): Forzamos 1 item (100% ancho) para que se vea bien.
    2. Escritorio (md en adelante): Usamos TU PROP 'visibleItems'.
       La fórmula calc(100% / número) hace que encajen exactos.
  */
  :global(.carousel-track > *) {
    flex-shrink: 0;
    height: 100%;
    scroll-snap-align: start;
    width: 100%; /* Por defecto en móvil se ve 1 */
    pointer-events: auto;
  }

  @media (min-width: 768px) {
    :global(.carousel-track > *) {
      width: calc(100% / var(--items-count));
    }
  }
</style>

<script>
  // Inicializar todos los carouseles en la página
  document.querySelectorAll('.carousel-container').forEach((container) => {
    const track = container.querySelector('.carousel-track') as HTMLElement;
    const btnPrev = container.querySelector('.btn-prev') as HTMLElement;
    const btnNext = container.querySelector('.btn-next') as HTMLElement;
    const counter = container.querySelector('.counter') as HTMLElement;
    const dotsContainer = container.querySelector('.dots-container') as HTMLElement;
  
    if (track && btnPrev && btnNext) {
      const items = Array.from(track.children);
      const totalItems = items.length;
      const isInfinite = track.dataset.infinite === 'true';
      const autoplayTime = parseInt(track.dataset.autoplay || '0');
      let clonedItems: Element[] = [];
      let autoplayInterval: number | null = null;
      let isJumping = false;

      // Variables para el drag con mouse
      let isDragging = false;
      let startX = 0;
      let scrollLeft = 0;
      let momentumID: number | null = null;
      let velocity = 0;
      let lastX = 0;
      let lastTime = 0;

      // Constante de sensibilidad del drag (0.0 - 1.0)
      // Valores más bajos = movimiento más suave y pesado (estilo Netflix/Apple)
      const DRAG_SENSITIVITY = 0.9;

      // === ESTADO DEL CARRUSEL BASADO EN POSICIONES ===
      let currentIndex = 0; // Índice de la posición actual del viewport
      let visibleItems = getVisibleItems(); // Cantidad de items visibles en el viewport
      let totalPositions = Math.max(1, totalItems - visibleItems + 1); // Total de posiciones posibles

      // Función para obtener la cantidad de items visibles según el viewport
      function getVisibleItems(): number {
        if (window.innerWidth < 768) {
          return 1; // En móvil siempre 1
        }
        // En desktop, leer del CSS custom property
        const computedStyle = getComputedStyle(track);
        const itemsCount = computedStyle.getPropertyValue('--items-count').trim();
        return parseInt(itemsCount) || 4;
      }

      // Actualizar cálculos cuando cambie el tamaño de pantalla
      function recalculate() {
        const newVisibleItems = getVisibleItems();
        if (newVisibleItems !== visibleItems) {
          visibleItems = newVisibleItems;
          totalPositions = Math.max(1, totalItems - visibleItems + 1);
          currentIndex = Math.min(currentIndex, totalPositions - 1);
          regenerateDots();
          updateIndicator();
        }
      }

      // Listener para responsive
      let resizeTimeout: number;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(recalculate, 150);
      });

      // Si es infinito, clonar items al inicio y al final
      if (isInfinite && totalItems > 0) {
        // Clonar los últimos items al inicio
        for (let i = totalItems - 1; i >= 0; i--) {
          const clone = items[i].cloneNode(true) as Element;
          clone.classList.add('cloned');
          track.insertBefore(clone, track.firstChild);
          clonedItems.push(clone);
        }
        
        // Clonar los primeros items al final
        for (let i = 0; i < totalItems; i++) {
          const clone = items[i].cloneNode(true) as Element;
          clone.classList.add('cloned');
          track.appendChild(clone);
          clonedItems.push(clone);
        }

        // Posicionar en el primer item real (después de los clones iniciales)
        const itemWidth = items[0].clientWidth;
        track.scrollLeft = itemWidth * totalItems;
      }

      // Generar dots basados en totalPositions
      function regenerateDots() {
        if (!dotsContainer) return;
        
        // Limpiar dots existentes
        dotsContainer.innerHTML = '';
        
        // Crear dots basados en posiciones del viewport
        for (let i = 0; i < totalPositions; i++) {
          const dot = document.createElement('div');
          dot.className = `w-2 h-2 rounded-full transition-all cursor-pointer ${i === 0 ? 'bg-white scale-125' : 'bg-white/50'}`;
          dot.dataset.index = i.toString();
          
          // Click en dot navega a esa posición
          dot.addEventListener('click', () => {
            goToPosition(i);
          });
          
          dotsContainer.appendChild(dot);
        }
      }

      // Inicializar indicadores
      regenerateDots();
      updateIndicator();

      // === FUNCIONES DE NAVEGACIÓN ===
      
      // Navegar a una posición específica del viewport
      function goToPosition(index: number) {
        // Limitar índice
        index = Math.max(0, Math.min(index, totalPositions - 1));
        currentIndex = index;
        
        // Calcular scroll necesario
        const itemWidth = items[0].clientWidth;
        const targetScroll = itemWidth * currentIndex;
        
        track.scrollTo({ left: targetScroll, behavior: 'smooth' });
      }

      // Avanzar al siguiente slide (viewport completo o parcial)
      function goToNext() {
        if (currentIndex < totalPositions - 1) {
          goToPosition(currentIndex + 1);
        } else if (isInfinite) {
          // En modo infinito, continuar
          const itemWidth = items[0].clientWidth;
          track.scrollBy({ left: itemWidth, behavior: 'smooth' });
        }
      }

      // Retroceder al slide anterior
      function goToPrev() {
        if (currentIndex > 0) {
          goToPosition(currentIndex - 1);
        } else if (isInfinite) {
          // En modo infinito, continuar
          const itemWidth = items[0].clientWidth;
          track.scrollBy({ left: -itemWidth, behavior: 'smooth' });
        }
      }

      // Configurar autoplay si está habilitado
      function startAutoplay() {
        if (autoplayTime > 0 && !autoplayInterval) {
          autoplayInterval = window.setInterval(goToNext, autoplayTime);
        }
      }

      function stopAutoplay() {
        if (autoplayInterval) {
          clearInterval(autoplayInterval);
          autoplayInterval = null;
        }
      }

      // Iniciar autoplay
      startAutoplay();

      // Pausar autoplay al hover o interacción
      container.addEventListener('mouseenter', stopAutoplay);
      container.addEventListener('mouseleave', startAutoplay);

      // Eventos Click en botones
      btnNext.addEventListener('click', () => {
        stopAutoplay();
        goToNext();
        startAutoplay();
      });

      btnPrev.addEventListener('click', () => {
        stopAutoplay();
        goToPrev();
        startAutoplay();
      });

      // Pausar autoplay cuando el usuario hace scroll manual
      let scrollTimeout: number;
      track.addEventListener('scroll', () => {
        if (!isJumping) {
          updateIndicatorFromScroll();
        }
        
        if (isInfinite) {
          handleInfiniteScroll();
        }

        // Detectar scroll manual y pausar autoplay temporalmente
        if (autoplayTime > 0) {
          stopAutoplay();
          clearTimeout(scrollTimeout);
          scrollTimeout = window.setTimeout(startAutoplay, 3000);
        }
      });

      // === DRAG CON MOUSE ===
      
      // Función para aplicar inercia (momentum scrolling)
      function applyMomentum() {
        if (Math.abs(velocity) > 0.5) {
          track.scrollLeft -= velocity;
          velocity *= 0.95; // Fricción
          momentumID = requestAnimationFrame(applyMomentum);
        } else {
          velocity = 0;
          if (momentumID) {
            cancelAnimationFrame(momentumID);
            momentumID = null;
          }
        }
      }

      // Iniciar drag
      track.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.pageX - track.offsetLeft;
        scrollLeft = track.scrollLeft;
        lastX = e.pageX;
        lastTime = Date.now();
        velocity = 0;
        
        // Cancelar momentum anterior
        if (momentumID) {
          cancelAnimationFrame(momentumID);
          momentumID = null;
        }
        
        // Pausar autoplay
        stopAutoplay();
        
        // Prevenir selección de texto
        e.preventDefault();
      });

      // Mover mientras arrastra
      track.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        e.preventDefault();
        const x = e.pageX - track.offsetLeft;
        const walk = (x - startX) * DRAG_SENSITIVITY; // Aplicar sensibilidad al movimiento
        
        // Calcular velocidad
        const now = Date.now();
        const deltaTime = now - lastTime;
        const deltaX = e.pageX - lastX;
        
        if (deltaTime > 0) {
          velocity = (deltaX * DRAG_SENSITIVITY) / deltaTime * 10; // Aplicar sensibilidad a la velocidad
        }
        
        lastX = e.pageX;
        lastTime = now;
        
        track.scrollLeft = scrollLeft - walk;
      });

      // Finalizar drag
      const endDrag = () => {
        if (isDragging) {
          isDragging = false;
          
          // Aplicar momentum si hay velocidad
          if (Math.abs(velocity) > 1) {
            applyMomentum();
          }
          
          // Reanudar autoplay después de un tiempo
          if (autoplayTime > 0) {
            setTimeout(startAutoplay, 3000);
          }
        }
      };

      track.addEventListener('mouseup', endDrag);
      track.addEventListener('mouseleave', endDrag);

      // Prevenir clicks en enlaces durante drag
      track.addEventListener('click', (e) => {
        if (Math.abs(velocity) > 1) {
          e.preventDefault();
          e.stopPropagation();
        }
      }, true);

      // === FIN DRAG CON MOUSE ===

      function handleInfiniteScroll() {
        const itemWidth = track.children[0].clientWidth;
        const scrollPos = track.scrollLeft;
        const maxScroll = track.scrollWidth - track.clientWidth;

        // Si llegó al final (clones finales), saltar al inicio real
        if (scrollPos >= maxScroll - 10) {
          isJumping = true;
          track.scrollLeft = itemWidth * totalItems;
          requestAnimationFrame(() => {
            updateIndicatorFromScroll();
            isJumping = false;
          });
        }
        
        // Si llegó al inicio (clones iniciales), saltar al final real
        else if (scrollPos <= 10) {
          isJumping = true;
          track.scrollLeft = itemWidth * totalItems * 2 - track.clientWidth;
          requestAnimationFrame(() => {
            updateIndicatorFromScroll();
            isJumping = false;
          });
        }
      }

      // Actualizar indicador basado en la posición actual del scroll
      function updateIndicatorFromScroll() {
        const itemWidth = items[0].clientWidth;
        const scrollPos = track.scrollLeft;
        
        // Calcular el índice de posición basado en el scroll
        let calculatedIndex = Math.round(scrollPos / itemWidth);
        
        // Ajustar índice para carrusel infinito
        if (isInfinite && totalItems > 0) {
          calculatedIndex = ((calculatedIndex - totalItems) % totalItems + totalItems) % totalItems;
        }
        
        // Limitar al rango válido de posiciones
        calculatedIndex = Math.max(0, Math.min(calculatedIndex, totalPositions - 1));
        
        // Actualizar currentIndex
        currentIndex = calculatedIndex;
        
        updateIndicator();
      }

      // Actualizar la UI de los indicadores basado en currentIndex
      function updateIndicator() {
        // Actualizar contador numérico
        if (counter) {
          counter.innerText = `${currentIndex + 1} / ${totalPositions}`;
        }

        // Actualizar dots
        if (dotsContainer) {
          const dots = dotsContainer.querySelectorAll('div');
          dots.forEach((dot, index) => {
            if (index === currentIndex) {
              dot.className = 'w-2 h-2 rounded-full transition-all cursor-pointer bg-white scale-125';
            } else {
              dot.className = 'w-2 h-2 rounded-full transition-all cursor-pointer bg-white/50';
            }
          });
        }

        // Actualizar estado de botones (solo si no es infinito)
        if (!isInfinite) {
          if (currentIndex === 0) {
            btnPrev.classList.add('opacity-50', 'pointer-events-none');
          } else {
            btnPrev.classList.remove('opacity-50', 'pointer-events-none');
          }

          if (currentIndex === totalPositions - 1) {
            btnNext.classList.add('opacity-50', 'pointer-events-none');
          } else {
            btnNext.classList.remove('opacity-50', 'pointer-events-none');
          }
        }
      }
    }
  });
</script>